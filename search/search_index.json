{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"polymv","text":"<p>Welcome to the polymv documentation!</p> <p><code>polymv</code> is a Python/C package for converting multipolar coefficients (<code>alms</code>) into Multipole Vectors (MVs) and Fr\u00e9chet Vectors (FVs) for a given multipole. It's especially useful in cosmological studies, including the analysis of Planck 2015 and 2018 temperature maps.</p> <p>\ud83d\udd2d You can explore the MVs and FVs derived from Planck data here: </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Converts <code>alms</code> to Multipole Vectors (MVs) and Fr\u00e9chet Vectors (FVs)</li> <li>Designed for cosmological data analysis (e.g. Planck temperature maps)</li> <li>Includes ready-to-use notebooks and utilities</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with polymv, please refer to the following sections:</p> <ul> <li>Installation</li> <li>Usage</li> <li>Examples</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Make sure the following are installed on your system:</p> <ul> <li>Python \u2265 3.10</li> <li>GCC or another default Unix compiler</li> <li>Miniforge package manager</li> </ul> <p>\ud83d\uded1 Note: This package was developed for Unix-based systems. Windows support is not guaranteed.</p> <p>The installation steps were designed to use <code>conda</code> due to the large amount of binaries available.</p>"},{"location":"#steps","title":"Steps","text":"<ol> <li> <p>Clone the repository    <pre><code>git clone https://github.com/oliveirara/polymv.git\ncd polymv\n</code></pre></p> </li> <li> <p>Review the Makefile. It will install the following user-level dependencies:</p> <ul> <li>MPSolve</li> <li>chealpix</li> </ul> </li> <li> <p>Customize the config.mk. Adjust these settings as needed:</p> <ul> <li>Installation directory (defaults to user home directory)</li> <li>Package manager (<code>mamba</code> by default, can be changed to <code>conda</code>)</li> <li>Environment name</li> <li>Python version</li> </ul> </li> <li> <p>Run the installer    <pre><code>make install\n</code></pre></p> <p>Or changing the parameters online (no need to rewrite the <code>config.mk</code> file). For the example, I will change the environment name and Python version:    <pre><code>make install PYTHON_ENV=\"&lt;environment-name&gt;\" PYTHON_VERSION=\"&lt;custom-python-version&gt;\"\n</code></pre></p> </li> </ol> <p>That\u2019s it! \ud83c\udf89</p> <p>For more insight into what the installer is doing, check out the scripts folder.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the GNU General Public License v3. See the LICENSE file for details.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use <code>polymv</code> in your research, please cite:</p> <pre><code>@article{2020PDU....3000608O,\n       author = {{Oliveira}, Renan A. and {Pereira}, Thiago S. and {Quartin}, Miguel},\n        title = \"{CMB statistical isotropy confirmation at all scales using multipole vectors}\",\n      journal = {Physics of the Dark Universe},\n     keywords = {Observational cosmology, Cosmic microwave background, Statistical isotropy, Multipole vectors, Astrophysics - Cosmology and Nongalactic Astrophysics, Astrophysics - Instrumentation and Methods for Astrophysics, General Relativity and Quantum Cosmology},\n         year = 2020,\n        month = dec,\n       volume = {30},\n          eid = {100608},\n        pages = {100608},\n          doi = {10.1016/j.dark.2020.100608},\narchivePrefix = {arXiv},\n       eprint = {1812.02654},\n primaryClass = {astro-ph.CO},\n       adsurl = {https://ui.adsabs.harvard.edu/abs/2020PDU....3000608O},\n      adsnote = {Provided by the SAO/NASA Astrophysics Data System}\n}\n</code></pre> <p>and</p> <pre><code>@article{2024arXiv241108087R,\n       author = {{Rodrigues}, Ricardo G. and {Pereira}, Thiago S. and {Quartin}, Miguel},\n        title = \"{Fr{\\'e}chet Vectors as sensitive tools for blind tests of CMB anomalies}\",\n      journal = {arXiv e-prints},\n     keywords = {Astrophysics - Cosmology and Nongalactic Astrophysics, General Relativity and Quantum Cosmology},\n         year = 2024,\n        month = nov,\n          eid = {arXiv:2411.08087},\n        pages = {arXiv:2411.08087},\n          doi = {10.48550/arXiv.2411.08087},\narchivePrefix = {arXiv},\n       eprint = {2411.08087},\n primaryClass = {astro-ph.CO},\n       adsurl = {https://ui.adsabs.harvard.edu/abs/2024arXiv241108087R},\n      adsnote = {Provided by the SAO/NASA Astrophysics Data System}\n}\n</code></pre>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>This work was supported by:</p> <ul> <li>Conselho Nacional de Desenvolvimento Cient\u00edfico e Tecnol\u00f3gico (CNPq)</li> <li>Coordena\u00e7\u00e3o de Aperfei\u00e7oamento de Pessoal de N\u00edvel Superior (CAPES)</li> <li>Funda\u00e7\u00e3o Arauc\u00e1ria (PBA-2016)</li> </ul>"},{"location":"LICENSE/","title":"License","text":"<p>Copyright (C) 2025  Renan Alves de Oliveira and Ricardo Gonzatto Rodrigues</p> <p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p> <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p> <p>You should have received a copy of the GNU General Public License along with this program.  If not, see https://www.gnu.org/licenses/.</p>"},{"location":"test-example/","title":"polymv Test Example","text":"<p>This example demonstrates the usage and performance of the <code>polymv</code> package on a DELL XPS 8900 with a 6th Generation Intel\u00ae Core\u2122 i5-6400 Processor (2.7 GHz up to 3.3 GHz, 6MB Cache).</p>"},{"location":"test-example/#setup","title":"Setup","text":"<p>Import the necessary libraries:</p> <pre><code>import numpy as np\nimport healpy as hp\n\nfrom polymv import polymv\n</code></pre>"},{"location":"test-example/#explore-the-polymv-module","title":"Explore the <code>polymv</code> Module","text":"<p>Check the available functions and their docstrings:</p> <pre><code>help(polymv)\n</code></pre> <p>Output: <pre><code>Help on module polymv.polymv in polymv:\n\nNAME\n    polymv.polymv\n\nFUNCTIONS\n    fvs(input1, input2, LMAX)\n        Get Fr\u00e9chet mean vectors in spherical coordinates for a multipole given a map based on lmax.\n\n        Parameters:\n            input1 (float): Multipole vector theta coordinate.\n            input2 (float): Multipole vector phi coordinate.\n            LMAX (int): Maximum l value to compute the Fr\u00e9chet mean.\n\n        Returns:\n            array: An array for all Fr\u00e9chet mean based on all multipole vectors in spherical coordinates (theta, phi) from l=2 to lmax.\n\n    mvs(input1, input2, LMAX)\n        Get multipole vectors in spherical coordinates for a multipole given a map based on lmax.\n\n        Parameters:\n            input1 (float): Real part of multipole moments from a map (Healpy indexing).\n            input2 (float): Imaginary part of multipole moments from a map (Healpy indexing).\n            LMAX (int): Maximum l value to compute the multipole vectors.\n\n        Returns:\n            array: An array for all multipole vectors in spherical coordinates (theta, phi in radians) from l=2 to lmax.\n\nDATA\n    __test__ = {}\n\nFILE\n    /home/renan/polymv-project/polymv/polymv/polymv.cpython-312-x86_64-linux-gnu.so\n</code></pre></p>"},{"location":"test-example/#set-maximum-multipole","title":"Set Maximum Multipole","text":"<pre><code>lmax = 1000\n</code></pre>"},{"location":"test-example/#generate-random-multipole-data","title":"Generate Random Multipole Data","text":"<pre><code>%%time\nnp.random.seed(1)\nalm = hp.synalm(np.ones(2000), lmax=lmax)\nalm = np.column_stack([alm.real, alm.imag])\nalm.shape\n</code></pre> <p>Output: <pre><code>CPU times: user 43 ms, sys: 11.8 ms, total: 54.8 ms\nWall time: 54.3 ms\n\n(501501, 2)\n</code></pre></p>"},{"location":"test-example/#compute-multipole-vectors","title":"Compute Multipole Vectors","text":"<pre><code>%%time\nmvs = polymv.mvs(alm[:, 0], alm[:, 1], lmax)\nprint(type(mvs), [arr.shape for arr in mvs])\n</code></pre> <p>Output: <pre><code>CPU times: user 5min 50s, sys: 3.91 s, total: 5min 53s\nWall time: 1min 37s\n\n&lt;class 'tuple'&gt; [(1000998,), (1000998,)]\n</code></pre></p> <p>Show a sample of the multipole vectors:</p> <pre><code>print(\"theta:\", mvs[0][:5])\nprint(\"phi:\", mvs[1][:5])\n</code></pre> <p>Output: <pre><code>theta: [1.44757865 1.13235582 1.694014   1.07304038 0.03596525]\nphi:   [-0.23422314  1.99653803  2.90736952 -0.67228949  0.58064643]\n</code></pre></p>"},{"location":"test-example/#compute-frechet-mean-vectors","title":"Compute Fr\u00e9chet Mean Vectors","text":"<pre><code>%%time\nfvs = polymv.fvs(mvs[0], mvs[1], lmax)\nprint(type(fvs), [arr.shape for arr in fvs])\n</code></pre> <p>Output: <pre><code>CPU times: user 2min 46s, sys: 296 ms, total: 2min 47s\nWall time: 1min 10s\n\n&lt;class 'tuple'&gt; [(999,), (999,)]\n</code></pre></p> <p>Show a sample of the Fr\u00e9chet mean vectors:</p> <pre><code>print(\"theta:\", fvs[0][:5])\nprint(\"phi:\", fvs[1][:5])\n</code></pre> <p>Output: <pre><code>theta: [0.61105855 1.18990493 1.3201296  1.56128225 0.35433486]\nphi:   [4.30053475 2.58923118 4.61933201 6.0707641  0.62762944]\n</code></pre></p>"},{"location":"usage/","title":"polymv Usage Guide","text":"<p>This guide demonstrates how to use the main features of the <code>polymv</code> package for working with multipole vectors.</p>"},{"location":"usage/#setup","title":"Setup","text":"<p>Import the necessary libraries:</p> <pre><code>import numpy as np\nimport healpy as hp\n\nfrom polymv import polymv\nfrom polymv import utils\n</code></pre>"},{"location":"usage/#generating-test-data","title":"Generating Test Data","text":"<p>Let's create a test set of \\(a_{\\ell m}\\)s:</p> <pre><code>lmax = 1500\nnp.random.seed(1)\nalm = hp.synalm(np.ones(2000), lmax=lmax)\nalm = np.column_stack([alm.real, alm.imag])\nalm.shape\n</code></pre> <p>Output: <pre><code>(1127251, 2)\n</code></pre></p>"},{"location":"usage/#multipole-vectors-mvs","title":"Multipole Vectors (<code>mvs</code>)","text":"<p>To obtain multipole vectors from \\(\\ell=2\\) to \\(\\ell=1500\\):</p> <pre><code>mvs_1500 = polymv.mvs(alm[:, 0], alm[:, 1], lmax)\nnp.vstack(mvs_1500).shape\n</code></pre> <p>Output: <pre><code>(2, 2251498)\n</code></pre></p> <p>You can view a sample of the multipole vectors:</p> <pre><code>np.vstack(mvs_1500)[:, :5]\n</code></pre> <p>Output: <pre><code>array([[ 1.83441666,  1.37302603,  1.30717599,  1.52087956,  1.62071309],\n       [ 0.12767786,  1.33828394, -3.01391479,  0.19300013, -2.94859252]])\n</code></pre></p>"},{"location":"usage/#utility-functions","title":"Utility Functions","text":""},{"location":"usage/#extracting-specific-multipole-vectors","title":"Extracting Specific Multipole Vectors","text":"<p>Get multipole vectors for \\(\\ell=3\\):</p> <pre><code>utils.get_mvs_from_many(np.vstack(mvs_1500).T, 2, lmax, 3)\n</code></pre> <p>Output: <pre><code>array([[ 2.73836992,  2.08191869],\n       [ 1.52087956,  0.19300013],\n       [ 1.62071309, -2.94859252],\n       [ 2.34022757,  0.13144151],\n       [ 0.40322273, -1.05967396],\n       [ 0.80136509, -3.01015115]])\n</code></pre></p>"},{"location":"usage/#convert-to-cartesian-coordinates","title":"Convert to Cartesian Coordinates","text":"<p>Convert the multipole vectors to Cartesian coordinates:</p> <pre><code>cart_coords = utils.to_cart(np.vstack(mvs_1500).T)\ncart_coords[:3]\n</code></pre> <p>Output: <pre><code>array([[ 0.95759438,  0.12293233, -0.26057752],\n       [ 0.22593142,  0.95412221,  0.19648358],\n       [-0.95759438, -0.12293233,  0.26057752]])\n</code></pre></p>"},{"location":"usage/#filter-for-north-hemisphere","title":"Filter for North Hemisphere","text":"<p>Get only vectors in the north hemisphere:</p> <pre><code>north_mvs = utils.mvs_north(np.vstack(mvs_1500).T)\nnorth_mvs.shape\n</code></pre> <p>Output: <pre><code>(1125749, 2)\n</code></pre></p>"},{"location":"usage/#frechet-mean-vectors-fvs","title":"Fr\u00e9chet Mean Vectors (<code>fvs</code>)","text":"<p>Compute Fr\u00e9chet mean vectors for all multipoles:</p> <pre><code>fvs = polymv.fvs(mvs_1500[0], mvs_1500[1], lmax)\nnp.vstack(fvs).shape\n</code></pre> <p>Output: <pre><code>(2, 1498)\n</code></pre></p> <p>Show a sample:</p> <pre><code>np.vstack(fvs)[:, :5]\n</code></pre> <p>Output: <pre><code>array([[0.39372199, 1.30678037, 1.41442982, 1.18631234, 1.2620573 ],\n       [5.54727987, 1.64990686, 0.53026658, 2.88028155, 0.76763323]])\n</code></pre></p>"}]}